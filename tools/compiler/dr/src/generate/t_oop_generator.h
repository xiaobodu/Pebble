/*
 * Tencent is pleased to support the open source community by making Pebble available.
 * Copyright (C) 2016 THL A29 Limited, a Tencent company. All rights reserved.
 * Licensed under the MIT License (the "License"); you may not use this file except in compliance
 * with the License. You may obtain a copy of the License at
 * http://opensource.org/licenses/MIT
 * Unless required by applicable law or agreed to in writing, software distributed under the License
 * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 * or implied. See the License for the specific language governing permissions and limitations under
 * the License.
 *
 */


#ifndef T_OOP_GENERATOR_H
#define T_OOP_GENERATOR_H

#include <string>
#include <iostream>

#include "../globals.h"
#include "t_generator.h"
#include "../../version.h"

#include <algorithm>

/**
 * Class with utility methods shared across common object oriented languages.
 * Specifically, most of this stuff is for C++/Java.
 *
 */
class t_oop_generator : public t_generator {
 public:
  t_oop_generator(t_program* program) :
    t_generator(program) {}

  /**
   * Scoping, using curly braces!
   */

  void scope_up(std::ostream& out) {
    indent(out) << "{" << std::endl;
    indent_up();
  }

  void scope_down(std::ostream& out) {
    indent_down();
    indent(out) << "}" << std::endl;
  }

  std::string upcase_string(std::string original) {
    std::transform(original.begin(), original.end(), original.begin(), (int(*)(int)) toupper);
    return original;
  }

  /**
   * Generates a comment about this code being autogenerated, using C++ style
   * comments, which are also fair game in Java / PHP, yay!
   *
   * @return C-style comment mentioning that this file is autogenerated.
   */
  virtual std::string autogen_comment() {
    return
      std::string("/**\n") +
      " * " + autogen_summary() + "\n" +
      " *\n" +
      " * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING\n" +
      " *  @generated\n" +
      " * Copyright (c) 2015, Tencent Inc. All rights reserved.\n" +
      " */\n";
  }

  virtual std::string autogen_summary() {
    std::string version("Autogenerated by Pebble Compiler (");
    version.append(pebble::PebbleVersion::GetVersion());
    version.append(" ");
    version.append(__TIME__);
    version.append(" ");
    version.append(__DATE__);
    version.append(")");
    return version;
  }

  virtual std::string get_enum_class_name(t_type* type) {
    std::string package = "";
    t_program* program = type->get_program();
    if (program != NULL && program != program_) {
      package = program->get_namespace("java") + ".";
    }
    return package + type->get_name();
  }

  virtual void generate_java_docstring_comment(std::ofstream &out, std::string contents) {
    generate_docstring_comment(out,
                               "/**\n",
                               " * ", contents,
                               " */\n");
  }

  virtual void generate_java_doc(std::ofstream &out,
                                           t_field* field) {
    if (field->get_type()->is_enum()) {
      std::string combined_message = field->get_doc() + "\n@see " + get_enum_class_name(field->get_type());
      generate_java_docstring_comment(out, combined_message);
    } else {
      generate_java_doc(out, (t_doc*)field);
    }
  }

  /**
   * Emits a JavaDoc comment if the provided object has a doc in Thrift
   */
  virtual void generate_java_doc(std::ofstream &out,
                                           t_doc* tdoc) {
    if (tdoc->has_doc()) {
      generate_java_docstring_comment(out, tdoc->get_doc());
    }
  }

  /**
   * Emits a JavaDoc comment if the provided function object has a doc in Thrift
   */
  virtual void generate_java_doc(std::ofstream &out,
                                           t_function* tfunction) {
    if (tfunction->has_doc()) {
      std::stringstream ss;
      ss << tfunction->get_doc();
      const std::vector<t_field*>& fields = tfunction->get_arglist()->get_members();
      std::vector<t_field*>::const_iterator p_iter;
      for (p_iter = fields.begin(); p_iter != fields.end(); ++p_iter) {
        t_field* p = *p_iter;
        ss << "\n@param " << p->get_name();
        if (p->has_doc()) {
          ss << " " << p->get_doc();
        }
      }
      generate_docstring_comment(out,
                                 "/**\n",
                                 " * ", ss.str(),
                                 " */\n");
    }
  }
};

#endif

